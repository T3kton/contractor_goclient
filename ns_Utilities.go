// Package contractor - (version: "0.1") - Automatically generated by cinp-codegen from /api/v1/Utilities/ at 2025-09-11T18:21:28.030330
package contractor

import (
	"context"
	"fmt"
	cinp "github.com/cinp/go"
	"reflect"
	"strconv"
	"strings"
	"time"
)

// UtilitiesNetworked - Model Networked(/api/v1/Utilities/Networked)
/*
Networked(id, hostname, site)
*/
type UtilitiesNetworked struct {
	cinp.BaseObject
	cinp     cinp.CInPClient `json:"-"`
	Hostname *string         `json:"hostname,omitempty"`
	Site     *string         `json:"site,omitempty"`
	ID       *int            `json:"id,omitempty"`
}

// UtilitiesNetworkedNew - Make a new object of Model Networked
func (service *Contractor) UtilitiesNetworkedNew() *UtilitiesNetworked {
	return &UtilitiesNetworked{cinp: service.cinp}
}

// UtilitiesNetworkedNewWithID - Make a new object of Model Networked
func (service *Contractor) UtilitiesNetworkedNewWithID(id int) *UtilitiesNetworked {
	result := UtilitiesNetworked{cinp: service.cinp}
	result.SetURI("/api/v1/Utilities/Networked:" + strconv.FormatInt(int64(id), 10) + ":")
	return &result
}

// UtilitiesNetworkedGet - Get function for Model Networked
func (service *Contractor) UtilitiesNetworkedGet(ctx context.Context, id int) (*UtilitiesNetworked, error) {
	object, err := service.cinp.Get(ctx, "/api/v1/Utilities/Networked:"+strconv.FormatInt(int64(id), 10)+":")
	if err != nil {
		return nil, err
	}
	result := (*object).(*UtilitiesNetworked)
	result.cinp = service.cinp

	return result, nil
}

// UtilitiesNetworkedGetURI - Get function for Model Networked vi URI
func (service *Contractor) UtilitiesNetworkedGetURI(ctx context.Context, uri string) (*UtilitiesNetworked, error) {
	if !strings.HasPrefix(uri, "/api/v1/Utilities/Networked:") {
		return nil, fmt.Errorf("URI is not for a 'UtilitiesNetworked'")
	}

	object, err := service.cinp.Get(ctx, uri)
	if err != nil {
		return nil, err
	}
	result := (*object).(*UtilitiesNetworked)
	result.cinp = service.cinp

	return result, nil
}

// Create - Create function for Model Networked
// NOTE: the object will be updated with values from the server
func (object *UtilitiesNetworked) Create(ctx context.Context) error {
	err := object.cinp.Create(ctx, "/api/v1/Utilities/Networked", object)
	if err != nil {
		return err
	}

	return nil
}

// Update - Update function for Model Networked
// NOTE: the object will be updated with values from the server
func (object *UtilitiesNetworked) Update(ctx context.Context) error {
	err := object.cinp.Update(ctx, object)
	if err != nil {
		return err
	}

	return nil
}

// Delete - Delete function for Model Networked
func (object *UtilitiesNetworked) Delete(ctx context.Context) error {
	if err := object.cinp.Delete(ctx, object); err != nil {
		return err
	}

	return nil
}

// UtilitiesNetworkedListFilters - Return a slice of valid filter names Networked
func (service *Contractor) UtilitiesNetworkedListFilters() [0]string {
	return [0]string{}
}

// UtilitiesNetworkedList - List function for Model Networked
func (service *Contractor) UtilitiesNetworkedList(ctx context.Context, filterName string, filterValues map[string]interface{}) (<-chan *UtilitiesNetworked, error) {
	if filterName != "" {
		for _, item := range service.UtilitiesNetworkedListFilters() {
			if item == filterName {
				goto good
			}
		}
		return nil, fmt.Errorf("filter '%s' is invalid", filterName)
	}
good:

	in := service.cinp.ListObjects(ctx, "/api/v1/Utilities/Networked", reflect.TypeOf(UtilitiesNetworked{}), filterName, filterValues, 50)
	out := make(chan *UtilitiesNetworked)
	go func() {
		defer close(out)
		for v := range in {
			(*v).(*UtilitiesNetworked).cinp = service.cinp
			out <- (*v).(*UtilitiesNetworked)
		}
	}()
	return out, nil
}

// UtilitiesAddressBlock - Model AddressBlock(/api/v1/Utilities/AddressBlock)
/*
AddressBlock(id, name, site, subnet, prefix, gateway_offset, _max_address, updated, created)
*/
type UtilitiesAddressBlock struct {
	cinp.BaseObject
	cinp          cinp.CInPClient `json:"-"`
	Name          *string         `json:"name,omitempty"`
	Site          *string         `json:"site,omitempty"`
	Subnet        *string         `json:"subnet,omitempty"`
	Prefix        *int            `json:"prefix,omitempty"`
	GatewayOffset *int            `json:"gateway_offset,omitempty"`
	MaxAddress    *string         `json:"_max_address,omitempty"`
	Updated       *time.Time      `json:"updated,omitempty"`
	Created       *time.Time      `json:"created,omitempty"`
	ID            *int            `json:"id,omitempty"`
	Gateway       *string         `json:"gateway,omitempty"`
	Netmask       *string         `json:"netmask,omitempty"`
	Size          *string         `json:"size,omitempty"`
	Isipv4        *string         `json:"isIpV4,omitempty"`
}

// UtilitiesAddressBlockNew - Make a new object of Model AddressBlock
func (service *Contractor) UtilitiesAddressBlockNew() *UtilitiesAddressBlock {
	return &UtilitiesAddressBlock{cinp: service.cinp}
}

// UtilitiesAddressBlockNewWithID - Make a new object of Model AddressBlock
func (service *Contractor) UtilitiesAddressBlockNewWithID(id int) *UtilitiesAddressBlock {
	result := UtilitiesAddressBlock{cinp: service.cinp}
	result.SetURI("/api/v1/Utilities/AddressBlock:" + strconv.FormatInt(int64(id), 10) + ":")
	return &result
}

// UtilitiesAddressBlockGet - Get function for Model AddressBlock
func (service *Contractor) UtilitiesAddressBlockGet(ctx context.Context, id int) (*UtilitiesAddressBlock, error) {
	object, err := service.cinp.Get(ctx, "/api/v1/Utilities/AddressBlock:"+strconv.FormatInt(int64(id), 10)+":")
	if err != nil {
		return nil, err
	}
	result := (*object).(*UtilitiesAddressBlock)
	result.cinp = service.cinp

	return result, nil
}

// UtilitiesAddressBlockGetURI - Get function for Model AddressBlock vi URI
func (service *Contractor) UtilitiesAddressBlockGetURI(ctx context.Context, uri string) (*UtilitiesAddressBlock, error) {
	if !strings.HasPrefix(uri, "/api/v1/Utilities/AddressBlock:") {
		return nil, fmt.Errorf("URI is not for a 'UtilitiesAddressBlock'")
	}

	object, err := service.cinp.Get(ctx, uri)
	if err != nil {
		return nil, err
	}
	result := (*object).(*UtilitiesAddressBlock)
	result.cinp = service.cinp

	return result, nil
}

// Create - Create function for Model AddressBlock
// NOTE: the object will be updated with values from the server
func (object *UtilitiesAddressBlock) Create(ctx context.Context) error {
	err := object.cinp.Create(ctx, "/api/v1/Utilities/AddressBlock", object)
	if err != nil {
		return err
	}

	return nil
}

// Update - Update function for Model AddressBlock
// NOTE: the object will be updated with values from the server
func (object *UtilitiesAddressBlock) Update(ctx context.Context) error {
	err := object.cinp.Update(ctx, object)
	if err != nil {
		return err
	}

	return nil
}

// Delete - Delete function for Model AddressBlock
func (object *UtilitiesAddressBlock) Delete(ctx context.Context) error {
	if err := object.cinp.Delete(ctx, object); err != nil {
		return err
	}

	return nil
}

// UtilitiesAddressBlockListFilters - Return a slice of valid filter names AddressBlock
func (service *Contractor) UtilitiesAddressBlockListFilters() [1]string {
	return [1]string{"site"}
}

// UtilitiesAddressBlockList - List function for Model AddressBlock
func (service *Contractor) UtilitiesAddressBlockList(ctx context.Context, filterName string, filterValues map[string]interface{}) (<-chan *UtilitiesAddressBlock, error) {
	if filterName != "" {
		for _, item := range service.UtilitiesAddressBlockListFilters() {
			if item == filterName {
				goto good
			}
		}
		return nil, fmt.Errorf("filter '%s' is invalid", filterName)
	}
good:

	in := service.cinp.ListObjects(ctx, "/api/v1/Utilities/AddressBlock", reflect.TypeOf(UtilitiesAddressBlock{}), filterName, filterValues, 50)
	out := make(chan *UtilitiesAddressBlock)
	go func() {
		defer close(out)
		for v := range in {
			(*v).(*UtilitiesAddressBlock).cinp = service.cinp
			out <- (*v).(*UtilitiesAddressBlock)
		}
	}()
	return out, nil
}

// CallNextAddress calls nextAddress
func (object *UtilitiesAddressBlock) CallNextAddress(ctx context.Context, Networked string, InterfaceName string, IsPrimary bool) (string, error) {
	args := map[string]interface{}{
		"networked":      Networked,
		"interface_name": InterfaceName,
		"is_primary":     IsPrimary,
	}
	_, _, _, ids, _, err := object.cinp.GetURI().Split(object.GetURI())
	if err != nil {
		return "", err
	}
	uri, err := object.cinp.GetURI().UpdateIDs("/api/v1/Utilities/AddressBlock(nextAddress)", ids)
	if err != nil {
		return "", err
	}

	result := ""

	if err := object.cinp.Call(ctx, uri, &args, &result); err != nil {
		return "", err
	}

	return result, nil
}

// CallUsage calls usage
func (object *UtilitiesAddressBlock) CallUsage(ctx context.Context) (map[string]interface{}, error) {
	args := map[string]interface{}{}
	_, _, _, ids, _, err := object.cinp.GetURI().Split(object.GetURI())
	if err != nil {
		return nil, err
	}
	uri, err := object.cinp.GetURI().UpdateIDs("/api/v1/Utilities/AddressBlock(usage)", ids)
	if err != nil {
		return nil, err
	}

	result := map[string]interface{}{}

	if err := object.cinp.Call(ctx, uri, &args, &result); err != nil {
		return nil, err
	}

	return result, nil
}

// UtilitiesAddressBlockCallGetWithNameSite calls getWithNameSite
func (service *Contractor) UtilitiesAddressBlockCallGetWithNameSite(ctx context.Context, Site string, Name string) (string, error) {
	args := map[string]interface{}{
		"site": Site,
		"name": Name,
	}
	uri := "/api/v1/Utilities/AddressBlock(getWithNameSite)"

	result := ""

	if err := service.cinp.Call(ctx, uri, &args, &result); err != nil {
		return "", err
	}

	return result, nil
}

// UtilitiesNetwork - Model Network(/api/v1/Utilities/Network)
/*
Network(id, name, site, mtu, updated, created)
*/
type UtilitiesNetwork struct {
	cinp.BaseObject
	cinp             cinp.CInPClient `json:"-"`
	Name             *string         `json:"name,omitempty"`
	Site             *string         `json:"site,omitempty"`
	Mtu              *int            `json:"mtu,omitempty"`
	Updated          *time.Time      `json:"updated,omitempty"`
	Created          *time.Time      `json:"created,omitempty"`
	AddressBlockList *[]string       `json:"address_block_list,omitempty"`
	ID               *int            `json:"id,omitempty"`
}

// UtilitiesNetworkNew - Make a new object of Model Network
func (service *Contractor) UtilitiesNetworkNew() *UtilitiesNetwork {
	return &UtilitiesNetwork{cinp: service.cinp}
}

// UtilitiesNetworkNewWithID - Make a new object of Model Network
func (service *Contractor) UtilitiesNetworkNewWithID(id int) *UtilitiesNetwork {
	result := UtilitiesNetwork{cinp: service.cinp}
	result.SetURI("/api/v1/Utilities/Network:" + strconv.FormatInt(int64(id), 10) + ":")
	return &result
}

// UtilitiesNetworkGet - Get function for Model Network
func (service *Contractor) UtilitiesNetworkGet(ctx context.Context, id int) (*UtilitiesNetwork, error) {
	object, err := service.cinp.Get(ctx, "/api/v1/Utilities/Network:"+strconv.FormatInt(int64(id), 10)+":")
	if err != nil {
		return nil, err
	}
	result := (*object).(*UtilitiesNetwork)
	result.cinp = service.cinp

	return result, nil
}

// UtilitiesNetworkGetURI - Get function for Model Network vi URI
func (service *Contractor) UtilitiesNetworkGetURI(ctx context.Context, uri string) (*UtilitiesNetwork, error) {
	if !strings.HasPrefix(uri, "/api/v1/Utilities/Network:") {
		return nil, fmt.Errorf("URI is not for a 'UtilitiesNetwork'")
	}

	object, err := service.cinp.Get(ctx, uri)
	if err != nil {
		return nil, err
	}
	result := (*object).(*UtilitiesNetwork)
	result.cinp = service.cinp

	return result, nil
}

// Create - Create function for Model Network
// NOTE: the object will be updated with values from the server
func (object *UtilitiesNetwork) Create(ctx context.Context) error {
	err := object.cinp.Create(ctx, "/api/v1/Utilities/Network", object)
	if err != nil {
		return err
	}

	return nil
}

// Update - Update function for Model Network
// NOTE: the object will be updated with values from the server
func (object *UtilitiesNetwork) Update(ctx context.Context) error {
	err := object.cinp.Update(ctx, object)
	if err != nil {
		return err
	}

	return nil
}

// Delete - Delete function for Model Network
func (object *UtilitiesNetwork) Delete(ctx context.Context) error {
	if err := object.cinp.Delete(ctx, object); err != nil {
		return err
	}

	return nil
}

// UtilitiesNetworkListFilters - Return a slice of valid filter names Network
func (service *Contractor) UtilitiesNetworkListFilters() [1]string {
	return [1]string{"site"}
}

// UtilitiesNetworkList - List function for Model Network
func (service *Contractor) UtilitiesNetworkList(ctx context.Context, filterName string, filterValues map[string]interface{}) (<-chan *UtilitiesNetwork, error) {
	if filterName != "" {
		for _, item := range service.UtilitiesNetworkListFilters() {
			if item == filterName {
				goto good
			}
		}
		return nil, fmt.Errorf("filter '%s' is invalid", filterName)
	}
good:

	in := service.cinp.ListObjects(ctx, "/api/v1/Utilities/Network", reflect.TypeOf(UtilitiesNetwork{}), filterName, filterValues, 50)
	out := make(chan *UtilitiesNetwork)
	go func() {
		defer close(out)
		for v := range in {
			(*v).(*UtilitiesNetwork).cinp = service.cinp
			out <- (*v).(*UtilitiesNetwork)
		}
	}()
	return out, nil
}

// UtilitiesNetworkCallGetWithNameSite calls getWithNameSite
func (service *Contractor) UtilitiesNetworkCallGetWithNameSite(ctx context.Context, Site string, Name string) (string, error) {
	args := map[string]interface{}{
		"site": Site,
		"name": Name,
	}
	uri := "/api/v1/Utilities/Network(getWithNameSite)"

	result := ""

	if err := service.cinp.Call(ctx, uri, &args, &result); err != nil {
		return "", err
	}

	return result, nil
}

// UtilitiesNetworkAddressBlock - Model NetworkAddressBlock(/api/v1/Utilities/NetworkAddressBlock)
/*
NetworkAddressBlock(id, network, address_block, vlan, updated, created)
*/
type UtilitiesNetworkAddressBlock struct {
	cinp.BaseObject
	cinp         cinp.CInPClient `json:"-"`
	Network      *string         `json:"network,omitempty"`
	AddressBlock *string         `json:"address_block,omitempty"`
	Vlan         *int            `json:"vlan,omitempty"`
	Updated      *time.Time      `json:"updated,omitempty"`
	Created      *time.Time      `json:"created,omitempty"`
	ID           *int            `json:"id,omitempty"`
}

// UtilitiesNetworkAddressBlockNew - Make a new object of Model NetworkAddressBlock
func (service *Contractor) UtilitiesNetworkAddressBlockNew() *UtilitiesNetworkAddressBlock {
	return &UtilitiesNetworkAddressBlock{cinp: service.cinp}
}

// UtilitiesNetworkAddressBlockNewWithID - Make a new object of Model NetworkAddressBlock
func (service *Contractor) UtilitiesNetworkAddressBlockNewWithID(id int) *UtilitiesNetworkAddressBlock {
	result := UtilitiesNetworkAddressBlock{cinp: service.cinp}
	result.SetURI("/api/v1/Utilities/NetworkAddressBlock:" + strconv.FormatInt(int64(id), 10) + ":")
	return &result
}

// UtilitiesNetworkAddressBlockGet - Get function for Model NetworkAddressBlock
func (service *Contractor) UtilitiesNetworkAddressBlockGet(ctx context.Context, id int) (*UtilitiesNetworkAddressBlock, error) {
	object, err := service.cinp.Get(ctx, "/api/v1/Utilities/NetworkAddressBlock:"+strconv.FormatInt(int64(id), 10)+":")
	if err != nil {
		return nil, err
	}
	result := (*object).(*UtilitiesNetworkAddressBlock)
	result.cinp = service.cinp

	return result, nil
}

// UtilitiesNetworkAddressBlockGetURI - Get function for Model NetworkAddressBlock vi URI
func (service *Contractor) UtilitiesNetworkAddressBlockGetURI(ctx context.Context, uri string) (*UtilitiesNetworkAddressBlock, error) {
	if !strings.HasPrefix(uri, "/api/v1/Utilities/NetworkAddressBlock:") {
		return nil, fmt.Errorf("URI is not for a 'UtilitiesNetworkAddressBlock'")
	}

	object, err := service.cinp.Get(ctx, uri)
	if err != nil {
		return nil, err
	}
	result := (*object).(*UtilitiesNetworkAddressBlock)
	result.cinp = service.cinp

	return result, nil
}

// Create - Create function for Model NetworkAddressBlock
// NOTE: the object will be updated with values from the server
func (object *UtilitiesNetworkAddressBlock) Create(ctx context.Context) error {
	err := object.cinp.Create(ctx, "/api/v1/Utilities/NetworkAddressBlock", object)
	if err != nil {
		return err
	}

	return nil
}

// Update - Update function for Model NetworkAddressBlock
// NOTE: the object will be updated with values from the server
func (object *UtilitiesNetworkAddressBlock) Update(ctx context.Context) error {
	err := object.cinp.Update(ctx, object)
	if err != nil {
		return err
	}

	return nil
}

// Delete - Delete function for Model NetworkAddressBlock
func (object *UtilitiesNetworkAddressBlock) Delete(ctx context.Context) error {
	if err := object.cinp.Delete(ctx, object); err != nil {
		return err
	}

	return nil
}

// UtilitiesNetworkAddressBlockListFilters - Return a slice of valid filter names NetworkAddressBlock
func (service *Contractor) UtilitiesNetworkAddressBlockListFilters() [2]string {
	return [2]string{"network", "address_block"}
}

// UtilitiesNetworkAddressBlockList - List function for Model NetworkAddressBlock
func (service *Contractor) UtilitiesNetworkAddressBlockList(ctx context.Context, filterName string, filterValues map[string]interface{}) (<-chan *UtilitiesNetworkAddressBlock, error) {
	if filterName != "" {
		for _, item := range service.UtilitiesNetworkAddressBlockListFilters() {
			if item == filterName {
				goto good
			}
		}
		return nil, fmt.Errorf("filter '%s' is invalid", filterName)
	}
good:

	in := service.cinp.ListObjects(ctx, "/api/v1/Utilities/NetworkAddressBlock", reflect.TypeOf(UtilitiesNetworkAddressBlock{}), filterName, filterValues, 50)
	out := make(chan *UtilitiesNetworkAddressBlock)
	go func() {
		defer close(out)
		for v := range in {
			(*v).(*UtilitiesNetworkAddressBlock).cinp = service.cinp
			out <- (*v).(*UtilitiesNetworkAddressBlock)
		}
	}()
	return out, nil
}

// UtilitiesNetworkInterface - Model NetworkInterface(/api/v1/Utilities/NetworkInterface)
/*
NetworkInterface(id, name, network, updated, created)
*/
type UtilitiesNetworkInterface struct {
	cinp.BaseObject
	cinp    cinp.CInPClient `json:"-"`
	Name    *string         `json:"name,omitempty"`
	Network *string         `json:"network,omitempty"`
	Updated *time.Time      `json:"updated,omitempty"`
	Created *time.Time      `json:"created,omitempty"`
	ID      *int            `json:"id,omitempty"`
	Type    *string         `json:"type,omitempty"`
}

// UtilitiesNetworkInterfaceNew - Make a new object of Model NetworkInterface
func (service *Contractor) UtilitiesNetworkInterfaceNew() *UtilitiesNetworkInterface {
	return &UtilitiesNetworkInterface{cinp: service.cinp}
}

// UtilitiesNetworkInterfaceNewWithID - Make a new object of Model NetworkInterface
func (service *Contractor) UtilitiesNetworkInterfaceNewWithID(id int) *UtilitiesNetworkInterface {
	result := UtilitiesNetworkInterface{cinp: service.cinp}
	result.SetURI("/api/v1/Utilities/NetworkInterface:" + strconv.FormatInt(int64(id), 10) + ":")
	return &result
}

// UtilitiesRealNetworkInterface - Model RealNetworkInterface(/api/v1/Utilities/RealNetworkInterface)
/*
RealNetworkInterface(id, name, network, updated, created, networkinterface_ptr, mac, foundation, is_provisioning, physical_location, link_name, pxe)
*/
type UtilitiesRealNetworkInterface struct {
	cinp.BaseObject
	cinp             cinp.CInPClient `json:"-"`
	Name             *string         `json:"name,omitempty"`
	Network          *string         `json:"network,omitempty"`
	Updated          *time.Time      `json:"updated,omitempty"`
	Created          *time.Time      `json:"created,omitempty"`
	Mac              *string         `json:"mac,omitempty"`
	Foundation       *string         `json:"foundation,omitempty"`
	IsProvisioning   *bool           `json:"is_provisioning,omitempty"`
	PhysicalLocation *string         `json:"physical_location,omitempty"`
	LinkName         *string         `json:"link_name,omitempty"`
	Pxe              *string         `json:"pxe,omitempty"`
	ID               *int            `json:"id,omitempty"`
	Type             *string         `json:"type,omitempty"`
}

// UtilitiesRealNetworkInterfaceNew - Make a new object of Model RealNetworkInterface
func (service *Contractor) UtilitiesRealNetworkInterfaceNew() *UtilitiesRealNetworkInterface {
	return &UtilitiesRealNetworkInterface{cinp: service.cinp}
}

// UtilitiesRealNetworkInterfaceNewWithID - Make a new object of Model RealNetworkInterface
func (service *Contractor) UtilitiesRealNetworkInterfaceNewWithID(id int) *UtilitiesRealNetworkInterface {
	result := UtilitiesRealNetworkInterface{cinp: service.cinp}
	result.SetURI("/api/v1/Utilities/RealNetworkInterface:" + strconv.FormatInt(int64(id), 10) + ":")
	return &result
}

// UtilitiesRealNetworkInterfaceGet - Get function for Model RealNetworkInterface
func (service *Contractor) UtilitiesRealNetworkInterfaceGet(ctx context.Context, id int) (*UtilitiesRealNetworkInterface, error) {
	object, err := service.cinp.Get(ctx, "/api/v1/Utilities/RealNetworkInterface:"+strconv.FormatInt(int64(id), 10)+":")
	if err != nil {
		return nil, err
	}
	result := (*object).(*UtilitiesRealNetworkInterface)
	result.cinp = service.cinp

	return result, nil
}

// UtilitiesRealNetworkInterfaceGetURI - Get function for Model RealNetworkInterface vi URI
func (service *Contractor) UtilitiesRealNetworkInterfaceGetURI(ctx context.Context, uri string) (*UtilitiesRealNetworkInterface, error) {
	if !strings.HasPrefix(uri, "/api/v1/Utilities/RealNetworkInterface:") {
		return nil, fmt.Errorf("URI is not for a 'UtilitiesRealNetworkInterface'")
	}

	object, err := service.cinp.Get(ctx, uri)
	if err != nil {
		return nil, err
	}
	result := (*object).(*UtilitiesRealNetworkInterface)
	result.cinp = service.cinp

	return result, nil
}

// Create - Create function for Model RealNetworkInterface
// NOTE: the object will be updated with values from the server
func (object *UtilitiesRealNetworkInterface) Create(ctx context.Context) error {
	err := object.cinp.Create(ctx, "/api/v1/Utilities/RealNetworkInterface", object)
	if err != nil {
		return err
	}

	return nil
}

// Update - Update function for Model RealNetworkInterface
// NOTE: the object will be updated with values from the server
func (object *UtilitiesRealNetworkInterface) Update(ctx context.Context) error {
	err := object.cinp.Update(ctx, object)
	if err != nil {
		return err
	}

	return nil
}

// Delete - Delete function for Model RealNetworkInterface
func (object *UtilitiesRealNetworkInterface) Delete(ctx context.Context) error {
	if err := object.cinp.Delete(ctx, object); err != nil {
		return err
	}

	return nil
}

// UtilitiesRealNetworkInterfaceListFilters - Return a slice of valid filter names RealNetworkInterface
func (service *Contractor) UtilitiesRealNetworkInterfaceListFilters() [1]string {
	return [1]string{"foundation"}
}

// UtilitiesRealNetworkInterfaceList - List function for Model RealNetworkInterface
func (service *Contractor) UtilitiesRealNetworkInterfaceList(ctx context.Context, filterName string, filterValues map[string]interface{}) (<-chan *UtilitiesRealNetworkInterface, error) {
	if filterName != "" {
		for _, item := range service.UtilitiesRealNetworkInterfaceListFilters() {
			if item == filterName {
				goto good
			}
		}
		return nil, fmt.Errorf("filter '%s' is invalid", filterName)
	}
good:

	in := service.cinp.ListObjects(ctx, "/api/v1/Utilities/RealNetworkInterface", reflect.TypeOf(UtilitiesRealNetworkInterface{}), filterName, filterValues, 50)
	out := make(chan *UtilitiesRealNetworkInterface)
	go func() {
		defer close(out)
		for v := range in {
			(*v).(*UtilitiesRealNetworkInterface).cinp = service.cinp
			out <- (*v).(*UtilitiesRealNetworkInterface)
		}
	}()
	return out, nil
}

// UtilitiesAbstractNetworkInterface - Model AbstractNetworkInterface(/api/v1/Utilities/AbstractNetworkInterface)
/*
AbstractNetworkInterface(id, name, network, updated, created, networkinterface_ptr, structure)
*/
type UtilitiesAbstractNetworkInterface struct {
	cinp.BaseObject
	cinp      cinp.CInPClient `json:"-"`
	Name      *string         `json:"name,omitempty"`
	Network   *string         `json:"network,omitempty"`
	Updated   *time.Time      `json:"updated,omitempty"`
	Created   *time.Time      `json:"created,omitempty"`
	Structure *string         `json:"structure,omitempty"`
	ID        *int            `json:"id,omitempty"`
	Type      *string         `json:"type,omitempty"`
}

// UtilitiesAbstractNetworkInterfaceNew - Make a new object of Model AbstractNetworkInterface
func (service *Contractor) UtilitiesAbstractNetworkInterfaceNew() *UtilitiesAbstractNetworkInterface {
	return &UtilitiesAbstractNetworkInterface{cinp: service.cinp}
}

// UtilitiesAbstractNetworkInterfaceNewWithID - Make a new object of Model AbstractNetworkInterface
func (service *Contractor) UtilitiesAbstractNetworkInterfaceNewWithID(id int) *UtilitiesAbstractNetworkInterface {
	result := UtilitiesAbstractNetworkInterface{cinp: service.cinp}
	result.SetURI("/api/v1/Utilities/AbstractNetworkInterface:" + strconv.FormatInt(int64(id), 10) + ":")
	return &result
}

// UtilitiesAbstractNetworkInterfaceGet - Get function for Model AbstractNetworkInterface
func (service *Contractor) UtilitiesAbstractNetworkInterfaceGet(ctx context.Context, id int) (*UtilitiesAbstractNetworkInterface, error) {
	object, err := service.cinp.Get(ctx, "/api/v1/Utilities/AbstractNetworkInterface:"+strconv.FormatInt(int64(id), 10)+":")
	if err != nil {
		return nil, err
	}
	result := (*object).(*UtilitiesAbstractNetworkInterface)
	result.cinp = service.cinp

	return result, nil
}

// UtilitiesAbstractNetworkInterfaceGetURI - Get function for Model AbstractNetworkInterface vi URI
func (service *Contractor) UtilitiesAbstractNetworkInterfaceGetURI(ctx context.Context, uri string) (*UtilitiesAbstractNetworkInterface, error) {
	if !strings.HasPrefix(uri, "/api/v1/Utilities/AbstractNetworkInterface:") {
		return nil, fmt.Errorf("URI is not for a 'UtilitiesAbstractNetworkInterface'")
	}

	object, err := service.cinp.Get(ctx, uri)
	if err != nil {
		return nil, err
	}
	result := (*object).(*UtilitiesAbstractNetworkInterface)
	result.cinp = service.cinp

	return result, nil
}

// Create - Create function for Model AbstractNetworkInterface
// NOTE: the object will be updated with values from the server
func (object *UtilitiesAbstractNetworkInterface) Create(ctx context.Context) error {
	err := object.cinp.Create(ctx, "/api/v1/Utilities/AbstractNetworkInterface", object)
	if err != nil {
		return err
	}

	return nil
}

// Update - Update function for Model AbstractNetworkInterface
// NOTE: the object will be updated with values from the server
func (object *UtilitiesAbstractNetworkInterface) Update(ctx context.Context) error {
	err := object.cinp.Update(ctx, object)
	if err != nil {
		return err
	}

	return nil
}

// Delete - Delete function for Model AbstractNetworkInterface
func (object *UtilitiesAbstractNetworkInterface) Delete(ctx context.Context) error {
	if err := object.cinp.Delete(ctx, object); err != nil {
		return err
	}

	return nil
}

// UtilitiesAbstractNetworkInterfaceListFilters - Return a slice of valid filter names AbstractNetworkInterface
func (service *Contractor) UtilitiesAbstractNetworkInterfaceListFilters() [1]string {
	return [1]string{"structure"}
}

// UtilitiesAbstractNetworkInterfaceList - List function for Model AbstractNetworkInterface
func (service *Contractor) UtilitiesAbstractNetworkInterfaceList(ctx context.Context, filterName string, filterValues map[string]interface{}) (<-chan *UtilitiesAbstractNetworkInterface, error) {
	if filterName != "" {
		for _, item := range service.UtilitiesAbstractNetworkInterfaceListFilters() {
			if item == filterName {
				goto good
			}
		}
		return nil, fmt.Errorf("filter '%s' is invalid", filterName)
	}
good:

	in := service.cinp.ListObjects(ctx, "/api/v1/Utilities/AbstractNetworkInterface", reflect.TypeOf(UtilitiesAbstractNetworkInterface{}), filterName, filterValues, 50)
	out := make(chan *UtilitiesAbstractNetworkInterface)
	go func() {
		defer close(out)
		for v := range in {
			(*v).(*UtilitiesAbstractNetworkInterface).cinp = service.cinp
			out <- (*v).(*UtilitiesAbstractNetworkInterface)
		}
	}()
	return out, nil
}

// UtilitiesAggregatedNetworkInterface - Model AggregatedNetworkInterface(/api/v1/Utilities/AggregatedNetworkInterface)
/*
AggregatedNetworkInterface(id, name, network, updated, created, networkinterface_ptr, structure, abstractnetworkinterface_ptr, primary_interface, paramaters)
*/
type UtilitiesAggregatedNetworkInterface struct {
	cinp.BaseObject
	cinp                cinp.CInPClient         `json:"-"`
	Name                *string                 `json:"name,omitempty"`
	Network             *string                 `json:"network,omitempty"`
	Updated             *time.Time              `json:"updated,omitempty"`
	Created             *time.Time              `json:"created,omitempty"`
	Structure           *string                 `json:"structure,omitempty"`
	PrimaryInterface    *string                 `json:"primary_interface,omitempty"`
	Paramaters          *map[string]interface{} `json:"paramaters,omitempty"`
	SecondaryInterfaces *[]string               `json:"secondary_interfaces,omitempty"`
	NetworkinterfacePtr *string                 `json:"networkinterface_ptr,omitempty"`
	Type                *string                 `json:"type,omitempty"`
}

// UtilitiesAggregatedNetworkInterfaceNew - Make a new object of Model AggregatedNetworkInterface
func (service *Contractor) UtilitiesAggregatedNetworkInterfaceNew() *UtilitiesAggregatedNetworkInterface {
	return &UtilitiesAggregatedNetworkInterface{cinp: service.cinp}
}

// UtilitiesAggregatedNetworkInterfaceNewWithID - Make a new object of Model AggregatedNetworkInterface
func (service *Contractor) UtilitiesAggregatedNetworkInterfaceNewWithID(id string) *UtilitiesAggregatedNetworkInterface {
	result := UtilitiesAggregatedNetworkInterface{cinp: service.cinp}
	result.SetURI("/api/v1/Utilities/AggregatedNetworkInterface:" + id + ":")
	return &result
}

// UtilitiesAggregatedNetworkInterfaceGet - Get function for Model AggregatedNetworkInterface
func (service *Contractor) UtilitiesAggregatedNetworkInterfaceGet(ctx context.Context, id string) (*UtilitiesAggregatedNetworkInterface, error) {
	object, err := service.cinp.Get(ctx, "/api/v1/Utilities/AggregatedNetworkInterface:"+id+":")
	if err != nil {
		return nil, err
	}
	result := (*object).(*UtilitiesAggregatedNetworkInterface)
	result.cinp = service.cinp

	return result, nil
}

// UtilitiesAggregatedNetworkInterfaceGetURI - Get function for Model AggregatedNetworkInterface vi URI
func (service *Contractor) UtilitiesAggregatedNetworkInterfaceGetURI(ctx context.Context, uri string) (*UtilitiesAggregatedNetworkInterface, error) {
	if !strings.HasPrefix(uri, "/api/v1/Utilities/AggregatedNetworkInterface:") {
		return nil, fmt.Errorf("URI is not for a 'UtilitiesAggregatedNetworkInterface'")
	}

	object, err := service.cinp.Get(ctx, uri)
	if err != nil {
		return nil, err
	}
	result := (*object).(*UtilitiesAggregatedNetworkInterface)
	result.cinp = service.cinp

	return result, nil
}

// Create - Create function for Model AggregatedNetworkInterface
// NOTE: the object will be updated with values from the server
func (object *UtilitiesAggregatedNetworkInterface) Create(ctx context.Context) error {
	err := object.cinp.Create(ctx, "/api/v1/Utilities/AggregatedNetworkInterface", object)
	if err != nil {
		return err
	}

	return nil
}

// Update - Update function for Model AggregatedNetworkInterface
// NOTE: the object will be updated with values from the server
func (object *UtilitiesAggregatedNetworkInterface) Update(ctx context.Context) error {
	err := object.cinp.Update(ctx, object)
	if err != nil {
		return err
	}

	return nil
}

// Delete - Delete function for Model AggregatedNetworkInterface
func (object *UtilitiesAggregatedNetworkInterface) Delete(ctx context.Context) error {
	if err := object.cinp.Delete(ctx, object); err != nil {
		return err
	}

	return nil
}

// UtilitiesAggregatedNetworkInterfaceListFilters - Return a slice of valid filter names AggregatedNetworkInterface
func (service *Contractor) UtilitiesAggregatedNetworkInterfaceListFilters() [1]string {
	return [1]string{"structure"}
}

// UtilitiesAggregatedNetworkInterfaceList - List function for Model AggregatedNetworkInterface
func (service *Contractor) UtilitiesAggregatedNetworkInterfaceList(ctx context.Context, filterName string, filterValues map[string]interface{}) (<-chan *UtilitiesAggregatedNetworkInterface, error) {
	if filterName != "" {
		for _, item := range service.UtilitiesAggregatedNetworkInterfaceListFilters() {
			if item == filterName {
				goto good
			}
		}
		return nil, fmt.Errorf("filter '%s' is invalid", filterName)
	}
good:

	in := service.cinp.ListObjects(ctx, "/api/v1/Utilities/AggregatedNetworkInterface", reflect.TypeOf(UtilitiesAggregatedNetworkInterface{}), filterName, filterValues, 50)
	out := make(chan *UtilitiesAggregatedNetworkInterface)
	go func() {
		defer close(out)
		for v := range in {
			(*v).(*UtilitiesAggregatedNetworkInterface).cinp = service.cinp
			out <- (*v).(*UtilitiesAggregatedNetworkInterface)
		}
	}()
	return out, nil
}

// UtilitiesBaseAddress - Model BaseAddress(/api/v1/Utilities/BaseAddress)
/*
BaseAddress(id, address_block, offset, updated, created)
*/
type UtilitiesBaseAddress struct {
	cinp.BaseObject
	cinp         cinp.CInPClient `json:"-"`
	AddressBlock *string         `json:"address_block,omitempty"`
	Offset       *int            `json:"offset,omitempty"`
	Updated      *time.Time      `json:"updated,omitempty"`
	Created      *time.Time      `json:"created,omitempty"`
	ID           *int            `json:"id,omitempty"`
	Type         *string         `json:"type,omitempty"`
	IPAddress    *string         `json:"ip_address,omitempty"`
	Subnet       *string         `json:"subnet,omitempty"`
	Netmask      *string         `json:"netmask,omitempty"`
	Prefix       *string         `json:"prefix,omitempty"`
	Gateway      *string         `json:"gateway,omitempty"`
}

// UtilitiesBaseAddressNew - Make a new object of Model BaseAddress
func (service *Contractor) UtilitiesBaseAddressNew() *UtilitiesBaseAddress {
	return &UtilitiesBaseAddress{cinp: service.cinp}
}

// UtilitiesBaseAddressNewWithID - Make a new object of Model BaseAddress
func (service *Contractor) UtilitiesBaseAddressNewWithID(id int) *UtilitiesBaseAddress {
	result := UtilitiesBaseAddress{cinp: service.cinp}
	result.SetURI("/api/v1/Utilities/BaseAddress:" + strconv.FormatInt(int64(id), 10) + ":")
	return &result
}

// UtilitiesBaseAddressCallLookup calls lookup
func (service *Contractor) UtilitiesBaseAddressCallLookup(ctx context.Context, IPAddress string, Site string) (string, error) {
	args := map[string]interface{}{
		"ip_address": IPAddress,
		"site":       Site,
	}
	uri := "/api/v1/Utilities/BaseAddress(lookup)"

	result := ""

	if err := service.cinp.Call(ctx, uri, &args, &result); err != nil {
		return "", err
	}

	return result, nil
}

// UtilitiesAddress - Model Address(/api/v1/Utilities/Address)
/*
Address(id, address_block, offset, updated, created, baseaddress_ptr, networked, interface_name, alias_index, pointer, is_primary)
*/
type UtilitiesAddress struct {
	cinp.BaseObject
	cinp          cinp.CInPClient `json:"-"`
	AddressBlock  *string         `json:"address_block,omitempty"`
	Offset        *int            `json:"offset,omitempty"`
	Updated       *time.Time      `json:"updated,omitempty"`
	Created       *time.Time      `json:"created,omitempty"`
	Networked     *string         `json:"networked,omitempty"`
	InterfaceName *string         `json:"interface_name,omitempty"`
	AliasIndex    *int            `json:"alias_index,omitempty"`
	Pointer       *string         `json:"pointer,omitempty"`
	IsPrimary     *bool           `json:"is_primary,omitempty"`
	ID            *int            `json:"id,omitempty"`
	Type          *string         `json:"type,omitempty"`
	IPAddress     *string         `json:"ip_address,omitempty"`
	Subnet        *string         `json:"subnet,omitempty"`
	Netmask       *string         `json:"netmask,omitempty"`
	Prefix        *string         `json:"prefix,omitempty"`
	Gateway       *string         `json:"gateway,omitempty"`
}

// UtilitiesAddressNew - Make a new object of Model Address
func (service *Contractor) UtilitiesAddressNew() *UtilitiesAddress {
	return &UtilitiesAddress{cinp: service.cinp}
}

// UtilitiesAddressNewWithID - Make a new object of Model Address
func (service *Contractor) UtilitiesAddressNewWithID(id int) *UtilitiesAddress {
	result := UtilitiesAddress{cinp: service.cinp}
	result.SetURI("/api/v1/Utilities/Address:" + strconv.FormatInt(int64(id), 10) + ":")
	return &result
}

// UtilitiesAddressGet - Get function for Model Address
func (service *Contractor) UtilitiesAddressGet(ctx context.Context, id int) (*UtilitiesAddress, error) {
	object, err := service.cinp.Get(ctx, "/api/v1/Utilities/Address:"+strconv.FormatInt(int64(id), 10)+":")
	if err != nil {
		return nil, err
	}
	result := (*object).(*UtilitiesAddress)
	result.cinp = service.cinp

	return result, nil
}

// UtilitiesAddressGetURI - Get function for Model Address vi URI
func (service *Contractor) UtilitiesAddressGetURI(ctx context.Context, uri string) (*UtilitiesAddress, error) {
	if !strings.HasPrefix(uri, "/api/v1/Utilities/Address:") {
		return nil, fmt.Errorf("URI is not for a 'UtilitiesAddress'")
	}

	object, err := service.cinp.Get(ctx, uri)
	if err != nil {
		return nil, err
	}
	result := (*object).(*UtilitiesAddress)
	result.cinp = service.cinp

	return result, nil
}

// Create - Create function for Model Address
// NOTE: the object will be updated with values from the server
func (object *UtilitiesAddress) Create(ctx context.Context) error {
	err := object.cinp.Create(ctx, "/api/v1/Utilities/Address", object)
	if err != nil {
		return err
	}

	return nil
}

// Update - Update function for Model Address
// NOTE: the object will be updated with values from the server
func (object *UtilitiesAddress) Update(ctx context.Context) error {
	err := object.cinp.Update(ctx, object)
	if err != nil {
		return err
	}

	return nil
}

// Delete - Delete function for Model Address
func (object *UtilitiesAddress) Delete(ctx context.Context) error {
	if err := object.cinp.Delete(ctx, object); err != nil {
		return err
	}

	return nil
}

// UtilitiesAddressListFilters - Return a slice of valid filter names Address
func (service *Contractor) UtilitiesAddressListFilters() [2]string {
	return [2]string{"address_block", "structure"}
}

// UtilitiesAddressList - List function for Model Address
func (service *Contractor) UtilitiesAddressList(ctx context.Context, filterName string, filterValues map[string]interface{}) (<-chan *UtilitiesAddress, error) {
	if filterName != "" {
		for _, item := range service.UtilitiesAddressListFilters() {
			if item == filterName {
				goto good
			}
		}
		return nil, fmt.Errorf("filter '%s' is invalid", filterName)
	}
good:

	in := service.cinp.ListObjects(ctx, "/api/v1/Utilities/Address", reflect.TypeOf(UtilitiesAddress{}), filterName, filterValues, 50)
	out := make(chan *UtilitiesAddress)
	go func() {
		defer close(out)
		for v := range in {
			(*v).(*UtilitiesAddress).cinp = service.cinp
			out <- (*v).(*UtilitiesAddress)
		}
	}()
	return out, nil
}

// UtilitiesReservedAddress - Model ReservedAddress(/api/v1/Utilities/ReservedAddress)
/*
ReservedAddress(id, address_block, offset, updated, created, baseaddress_ptr, reason)
*/
type UtilitiesReservedAddress struct {
	cinp.BaseObject
	cinp         cinp.CInPClient `json:"-"`
	AddressBlock *string         `json:"address_block,omitempty"`
	Offset       *int            `json:"offset,omitempty"`
	Updated      *time.Time      `json:"updated,omitempty"`
	Created      *time.Time      `json:"created,omitempty"`
	Reason       *string         `json:"reason,omitempty"`
	ID           *int            `json:"id,omitempty"`
	Type         *string         `json:"type,omitempty"`
	IPAddress    *string         `json:"ip_address,omitempty"`
	Subnet       *string         `json:"subnet,omitempty"`
	Netmask      *string         `json:"netmask,omitempty"`
	Prefix       *string         `json:"prefix,omitempty"`
	Gateway      *string         `json:"gateway,omitempty"`
}

// UtilitiesReservedAddressNew - Make a new object of Model ReservedAddress
func (service *Contractor) UtilitiesReservedAddressNew() *UtilitiesReservedAddress {
	return &UtilitiesReservedAddress{cinp: service.cinp}
}

// UtilitiesReservedAddressNewWithID - Make a new object of Model ReservedAddress
func (service *Contractor) UtilitiesReservedAddressNewWithID(id int) *UtilitiesReservedAddress {
	result := UtilitiesReservedAddress{cinp: service.cinp}
	result.SetURI("/api/v1/Utilities/ReservedAddress:" + strconv.FormatInt(int64(id), 10) + ":")
	return &result
}

// UtilitiesReservedAddressGet - Get function for Model ReservedAddress
func (service *Contractor) UtilitiesReservedAddressGet(ctx context.Context, id int) (*UtilitiesReservedAddress, error) {
	object, err := service.cinp.Get(ctx, "/api/v1/Utilities/ReservedAddress:"+strconv.FormatInt(int64(id), 10)+":")
	if err != nil {
		return nil, err
	}
	result := (*object).(*UtilitiesReservedAddress)
	result.cinp = service.cinp

	return result, nil
}

// UtilitiesReservedAddressGetURI - Get function for Model ReservedAddress vi URI
func (service *Contractor) UtilitiesReservedAddressGetURI(ctx context.Context, uri string) (*UtilitiesReservedAddress, error) {
	if !strings.HasPrefix(uri, "/api/v1/Utilities/ReservedAddress:") {
		return nil, fmt.Errorf("URI is not for a 'UtilitiesReservedAddress'")
	}

	object, err := service.cinp.Get(ctx, uri)
	if err != nil {
		return nil, err
	}
	result := (*object).(*UtilitiesReservedAddress)
	result.cinp = service.cinp

	return result, nil
}

// Create - Create function for Model ReservedAddress
// NOTE: the object will be updated with values from the server
func (object *UtilitiesReservedAddress) Create(ctx context.Context) error {
	err := object.cinp.Create(ctx, "/api/v1/Utilities/ReservedAddress", object)
	if err != nil {
		return err
	}

	return nil
}

// Update - Update function for Model ReservedAddress
// NOTE: the object will be updated with values from the server
func (object *UtilitiesReservedAddress) Update(ctx context.Context) error {
	err := object.cinp.Update(ctx, object)
	if err != nil {
		return err
	}

	return nil
}

// Delete - Delete function for Model ReservedAddress
func (object *UtilitiesReservedAddress) Delete(ctx context.Context) error {
	if err := object.cinp.Delete(ctx, object); err != nil {
		return err
	}

	return nil
}

// UtilitiesReservedAddressListFilters - Return a slice of valid filter names ReservedAddress
func (service *Contractor) UtilitiesReservedAddressListFilters() [1]string {
	return [1]string{"address_block"}
}

// UtilitiesReservedAddressList - List function for Model ReservedAddress
func (service *Contractor) UtilitiesReservedAddressList(ctx context.Context, filterName string, filterValues map[string]interface{}) (<-chan *UtilitiesReservedAddress, error) {
	if filterName != "" {
		for _, item := range service.UtilitiesReservedAddressListFilters() {
			if item == filterName {
				goto good
			}
		}
		return nil, fmt.Errorf("filter '%s' is invalid", filterName)
	}
good:

	in := service.cinp.ListObjects(ctx, "/api/v1/Utilities/ReservedAddress", reflect.TypeOf(UtilitiesReservedAddress{}), filterName, filterValues, 50)
	out := make(chan *UtilitiesReservedAddress)
	go func() {
		defer close(out)
		for v := range in {
			(*v).(*UtilitiesReservedAddress).cinp = service.cinp
			out <- (*v).(*UtilitiesReservedAddress)
		}
	}()
	return out, nil
}

// UtilitiesDynamicAddress - Model DynamicAddress(/api/v1/Utilities/DynamicAddress)
/*
DynamicAddress(id, address_block, offset, updated, created, baseaddress_ptr, pxe)
*/
type UtilitiesDynamicAddress struct {
	cinp.BaseObject
	cinp         cinp.CInPClient `json:"-"`
	AddressBlock *string         `json:"address_block,omitempty"`
	Offset       *int            `json:"offset,omitempty"`
	Updated      *time.Time      `json:"updated,omitempty"`
	Created      *time.Time      `json:"created,omitempty"`
	Pxe          *string         `json:"pxe,omitempty"`
	ID           *int            `json:"id,omitempty"`
	Type         *string         `json:"type,omitempty"`
	IPAddress    *string         `json:"ip_address,omitempty"`
	Subnet       *string         `json:"subnet,omitempty"`
	Netmask      *string         `json:"netmask,omitempty"`
	Prefix       *string         `json:"prefix,omitempty"`
	Gateway      *string         `json:"gateway,omitempty"`
}

// UtilitiesDynamicAddressNew - Make a new object of Model DynamicAddress
func (service *Contractor) UtilitiesDynamicAddressNew() *UtilitiesDynamicAddress {
	return &UtilitiesDynamicAddress{cinp: service.cinp}
}

// UtilitiesDynamicAddressNewWithID - Make a new object of Model DynamicAddress
func (service *Contractor) UtilitiesDynamicAddressNewWithID(id int) *UtilitiesDynamicAddress {
	result := UtilitiesDynamicAddress{cinp: service.cinp}
	result.SetURI("/api/v1/Utilities/DynamicAddress:" + strconv.FormatInt(int64(id), 10) + ":")
	return &result
}

// UtilitiesDynamicAddressGet - Get function for Model DynamicAddress
func (service *Contractor) UtilitiesDynamicAddressGet(ctx context.Context, id int) (*UtilitiesDynamicAddress, error) {
	object, err := service.cinp.Get(ctx, "/api/v1/Utilities/DynamicAddress:"+strconv.FormatInt(int64(id), 10)+":")
	if err != nil {
		return nil, err
	}
	result := (*object).(*UtilitiesDynamicAddress)
	result.cinp = service.cinp

	return result, nil
}

// UtilitiesDynamicAddressGetURI - Get function for Model DynamicAddress vi URI
func (service *Contractor) UtilitiesDynamicAddressGetURI(ctx context.Context, uri string) (*UtilitiesDynamicAddress, error) {
	if !strings.HasPrefix(uri, "/api/v1/Utilities/DynamicAddress:") {
		return nil, fmt.Errorf("URI is not for a 'UtilitiesDynamicAddress'")
	}

	object, err := service.cinp.Get(ctx, uri)
	if err != nil {
		return nil, err
	}
	result := (*object).(*UtilitiesDynamicAddress)
	result.cinp = service.cinp

	return result, nil
}

// Create - Create function for Model DynamicAddress
// NOTE: the object will be updated with values from the server
func (object *UtilitiesDynamicAddress) Create(ctx context.Context) error {
	err := object.cinp.Create(ctx, "/api/v1/Utilities/DynamicAddress", object)
	if err != nil {
		return err
	}

	return nil
}

// Update - Update function for Model DynamicAddress
// NOTE: the object will be updated with values from the server
func (object *UtilitiesDynamicAddress) Update(ctx context.Context) error {
	err := object.cinp.Update(ctx, object)
	if err != nil {
		return err
	}

	return nil
}

// Delete - Delete function for Model DynamicAddress
func (object *UtilitiesDynamicAddress) Delete(ctx context.Context) error {
	if err := object.cinp.Delete(ctx, object); err != nil {
		return err
	}

	return nil
}

// UtilitiesDynamicAddressListFilters - Return a slice of valid filter names DynamicAddress
func (service *Contractor) UtilitiesDynamicAddressListFilters() [1]string {
	return [1]string{"address_block"}
}

// UtilitiesDynamicAddressList - List function for Model DynamicAddress
func (service *Contractor) UtilitiesDynamicAddressList(ctx context.Context, filterName string, filterValues map[string]interface{}) (<-chan *UtilitiesDynamicAddress, error) {
	if filterName != "" {
		for _, item := range service.UtilitiesDynamicAddressListFilters() {
			if item == filterName {
				goto good
			}
		}
		return nil, fmt.Errorf("filter '%s' is invalid", filterName)
	}
good:

	in := service.cinp.ListObjects(ctx, "/api/v1/Utilities/DynamicAddress", reflect.TypeOf(UtilitiesDynamicAddress{}), filterName, filterValues, 50)
	out := make(chan *UtilitiesDynamicAddress)
	go func() {
		defer close(out)
		for v := range in {
			(*v).(*UtilitiesDynamicAddress).cinp = service.cinp
			out <- (*v).(*UtilitiesDynamicAddress)
		}
	}()
	return out, nil
}

func registerUtilities(cinp cinp.CInPClient) {
	cinp.RegisterType("/api/v1/Utilities/Networked", reflect.TypeOf((*UtilitiesNetworked)(nil)).Elem())
	cinp.RegisterType("/api/v1/Utilities/AddressBlock", reflect.TypeOf((*UtilitiesAddressBlock)(nil)).Elem())
	cinp.RegisterType("/api/v1/Utilities/Network", reflect.TypeOf((*UtilitiesNetwork)(nil)).Elem())
	cinp.RegisterType("/api/v1/Utilities/NetworkAddressBlock", reflect.TypeOf((*UtilitiesNetworkAddressBlock)(nil)).Elem())
	cinp.RegisterType("/api/v1/Utilities/NetworkInterface", reflect.TypeOf((*UtilitiesNetworkInterface)(nil)).Elem())
	cinp.RegisterType("/api/v1/Utilities/RealNetworkInterface", reflect.TypeOf((*UtilitiesRealNetworkInterface)(nil)).Elem())
	cinp.RegisterType("/api/v1/Utilities/AbstractNetworkInterface", reflect.TypeOf((*UtilitiesAbstractNetworkInterface)(nil)).Elem())
	cinp.RegisterType("/api/v1/Utilities/AggregatedNetworkInterface", reflect.TypeOf((*UtilitiesAggregatedNetworkInterface)(nil)).Elem())
	cinp.RegisterType("/api/v1/Utilities/BaseAddress", reflect.TypeOf((*UtilitiesBaseAddress)(nil)).Elem())
	cinp.RegisterType("/api/v1/Utilities/Address", reflect.TypeOf((*UtilitiesAddress)(nil)).Elem())
	cinp.RegisterType("/api/v1/Utilities/ReservedAddress", reflect.TypeOf((*UtilitiesReservedAddress)(nil)).Elem())
	cinp.RegisterType("/api/v1/Utilities/DynamicAddress", reflect.TypeOf((*UtilitiesDynamicAddress)(nil)).Elem())
}
