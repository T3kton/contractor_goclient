// Package contractor - (version: "0.1") - Automatically generated by cinp-codegen from /api/v1/LibVirt/ at 2025-09-11T18:21:28.030330
/*
Plugin for VirtualBox.
*/
package contractor

import (
	"context"
	"fmt"
	cinp "github.com/cinp/go"
	"reflect"
	"strings"
	"time"
)

// LibvirtLibVirtComplex - Model LibVirtComplex(/api/v1/LibVirt/LibVirtComplex)
/*
Complex for LibVirt.  Only one member is allowed.  The ip address
for managing the LibVirt instance comes from the member's primary ip.
*/
type LibvirtLibVirtComplex struct {
	cinp.BaseObject
	cinp            cinp.CInPClient `json:"-"`
	Name            *string         `json:"name,omitempty"`
	Site            *string         `json:"site,omitempty"`
	Description     *string         `json:"description,omitempty"`
	BuiltPercentage *int            `json:"built_percentage,omitempty"`
	Updated         *time.Time      `json:"updated,omitempty"`
	Created         *time.Time      `json:"created,omitempty"`
	Members         *[]string       `json:"members,omitempty"`
	State           *string         `json:"state,omitempty"`
	Type            *string         `json:"type,omitempty"`
}

// LibvirtLibVirtComplexNew - Make a new object of Model LibVirtComplex
func (service *Contractor) LibvirtLibVirtComplexNew() *LibvirtLibVirtComplex {
	return &LibvirtLibVirtComplex{cinp: service.cinp}
}

// LibvirtLibVirtComplexNewWithID - Make a new object of Model LibVirtComplex
func (service *Contractor) LibvirtLibVirtComplexNewWithID(id string) *LibvirtLibVirtComplex {
	result := LibvirtLibVirtComplex{cinp: service.cinp}
	result.SetURI("/api/v1/LibVirt/LibVirtComplex:" + id + ":")
	return &result
}

// LibvirtLibVirtComplexGet - Get function for Model LibVirtComplex
func (service *Contractor) LibvirtLibVirtComplexGet(ctx context.Context, id string) (*LibvirtLibVirtComplex, error) {
	object, err := service.cinp.Get(ctx, "/api/v1/LibVirt/LibVirtComplex:"+id+":")
	if err != nil {
		return nil, err
	}
	result := (*object).(*LibvirtLibVirtComplex)
	result.cinp = service.cinp

	return result, nil
}

// LibvirtLibVirtComplexGetURI - Get function for Model LibVirtComplex vi URI
func (service *Contractor) LibvirtLibVirtComplexGetURI(ctx context.Context, uri string) (*LibvirtLibVirtComplex, error) {
	if !strings.HasPrefix(uri, "/api/v1/LibVirt/LibVirtComplex:") {
		return nil, fmt.Errorf("URI is not for a 'LibvirtLibVirtComplex'")
	}

	object, err := service.cinp.Get(ctx, uri)
	if err != nil {
		return nil, err
	}
	result := (*object).(*LibvirtLibVirtComplex)
	result.cinp = service.cinp

	return result, nil
}

// Create - Create function for Model LibVirtComplex
// NOTE: the object will be updated with values from the server
func (object *LibvirtLibVirtComplex) Create(ctx context.Context) error {
	err := object.cinp.Create(ctx, "/api/v1/LibVirt/LibVirtComplex", object)
	if err != nil {
		return err
	}

	return nil
}

// Update - Update function for Model LibVirtComplex
// NOTE: the object will be updated with values from the server
func (object *LibvirtLibVirtComplex) Update(ctx context.Context) error {
	err := object.cinp.Update(ctx, object)
	if err != nil {
		return err
	}

	return nil
}

// Delete - Delete function for Model LibVirtComplex
func (object *LibvirtLibVirtComplex) Delete(ctx context.Context) error {
	if err := object.cinp.Delete(ctx, object); err != nil {
		return err
	}

	return nil
}

// LibvirtLibVirtComplexListFilters - Return a slice of valid filter names LibVirtComplex
func (service *Contractor) LibvirtLibVirtComplexListFilters() [0]string {
	return [0]string{}
}

// LibvirtLibVirtComplexList - List function for Model LibVirtComplex
func (service *Contractor) LibvirtLibVirtComplexList(ctx context.Context, filterName string, filterValues map[string]interface{}) (<-chan *LibvirtLibVirtComplex, error) {
	if filterName != "" {
		for _, item := range service.LibvirtLibVirtComplexListFilters() {
			if item == filterName {
				goto good
			}
		}
		return nil, fmt.Errorf("filter '%s' is invalid", filterName)
	}
good:

	in := service.cinp.ListObjects(ctx, "/api/v1/LibVirt/LibVirtComplex", reflect.TypeOf(LibvirtLibVirtComplex{}), filterName, filterValues, 50)
	out := make(chan *LibvirtLibVirtComplex)
	go func() {
		defer close(out)
		for v := range in {
			(*v).(*LibvirtLibVirtComplex).cinp = service.cinp
			out <- (*v).(*LibvirtLibVirtComplex)
		}
	}()
	return out, nil
}

// LibvirtLibVirtFoundation - Model LibVirtFoundation(/api/v1/LibVirt/LibVirtFoundation)
/*
Foundation for use with LibVirtComplex.  Foundation instances are tracked
by the LibVirt UUID.
*/
type LibvirtLibVirtFoundation struct {
	cinp.BaseObject
	cinp           cinp.CInPClient `json:"-"`
	Locator        *string         `json:"locator,omitempty"`
	Site           *string         `json:"site,omitempty"`
	Blueprint      *string         `json:"blueprint,omitempty"`
	IDMap          *string         `json:"id_map,omitempty"`
	LocatedAt      *time.Time      `json:"located_at,omitempty"`
	BuiltAt        *time.Time      `json:"built_at,omitempty"`
	Updated        *time.Time      `json:"updated,omitempty"`
	Created        *time.Time      `json:"created,omitempty"`
	LibvirtComplex *string         `json:"libvirt_complex,omitempty"`
	LibvirtUUID    *string         `json:"libvirt_uuid,omitempty"`
	State          *string         `json:"state,omitempty"`
	Type           *string         `json:"type,omitempty"`
	ClassList      *string         `json:"class_list,omitempty"`
}

// LibvirtLibVirtFoundationNew - Make a new object of Model LibVirtFoundation
func (service *Contractor) LibvirtLibVirtFoundationNew() *LibvirtLibVirtFoundation {
	return &LibvirtLibVirtFoundation{cinp: service.cinp}
}

// LibvirtLibVirtFoundationNewWithID - Make a new object of Model LibVirtFoundation
func (service *Contractor) LibvirtLibVirtFoundationNewWithID(id string) *LibvirtLibVirtFoundation {
	result := LibvirtLibVirtFoundation{cinp: service.cinp}
	result.SetURI("/api/v1/LibVirt/LibVirtFoundation:" + id + ":")
	return &result
}

// LibvirtLibVirtFoundationGet - Get function for Model LibVirtFoundation
func (service *Contractor) LibvirtLibVirtFoundationGet(ctx context.Context, id string) (*LibvirtLibVirtFoundation, error) {
	object, err := service.cinp.Get(ctx, "/api/v1/LibVirt/LibVirtFoundation:"+id+":")
	if err != nil {
		return nil, err
	}
	result := (*object).(*LibvirtLibVirtFoundation)
	result.cinp = service.cinp

	return result, nil
}

// LibvirtLibVirtFoundationGetURI - Get function for Model LibVirtFoundation vi URI
func (service *Contractor) LibvirtLibVirtFoundationGetURI(ctx context.Context, uri string) (*LibvirtLibVirtFoundation, error) {
	if !strings.HasPrefix(uri, "/api/v1/LibVirt/LibVirtFoundation:") {
		return nil, fmt.Errorf("URI is not for a 'LibvirtLibVirtFoundation'")
	}

	object, err := service.cinp.Get(ctx, uri)
	if err != nil {
		return nil, err
	}
	result := (*object).(*LibvirtLibVirtFoundation)
	result.cinp = service.cinp

	return result, nil
}

// Create - Create function for Model LibVirtFoundation
// NOTE: the object will be updated with values from the server
func (object *LibvirtLibVirtFoundation) Create(ctx context.Context) error {
	err := object.cinp.Create(ctx, "/api/v1/LibVirt/LibVirtFoundation", object)
	if err != nil {
		return err
	}

	return nil
}

// Update - Update function for Model LibVirtFoundation
// NOTE: the object will be updated with values from the server
func (object *LibvirtLibVirtFoundation) Update(ctx context.Context) error {
	err := object.cinp.Update(ctx, object)
	if err != nil {
		return err
	}

	return nil
}

// Delete - Delete function for Model LibVirtFoundation
func (object *LibvirtLibVirtFoundation) Delete(ctx context.Context) error {
	if err := object.cinp.Delete(ctx, object); err != nil {
		return err
	}

	return nil
}

// LibvirtLibVirtFoundationListFilters - Return a slice of valid filter names LibVirtFoundation
func (service *Contractor) LibvirtLibVirtFoundationListFilters() [1]string {
	return [1]string{"site"}
}

// LibvirtLibVirtFoundationList - List function for Model LibVirtFoundation
func (service *Contractor) LibvirtLibVirtFoundationList(ctx context.Context, filterName string, filterValues map[string]interface{}) (<-chan *LibvirtLibVirtFoundation, error) {
	if filterName != "" {
		for _, item := range service.LibvirtLibVirtFoundationListFilters() {
			if item == filterName {
				goto good
			}
		}
		return nil, fmt.Errorf("filter '%s' is invalid", filterName)
	}
good:

	in := service.cinp.ListObjects(ctx, "/api/v1/LibVirt/LibVirtFoundation", reflect.TypeOf(LibvirtLibVirtFoundation{}), filterName, filterValues, 50)
	out := make(chan *LibvirtLibVirtFoundation)
	go func() {
		defer close(out)
		for v := range in {
			(*v).(*LibvirtLibVirtFoundation).cinp = service.cinp
			out <- (*v).(*LibvirtLibVirtFoundation)
		}
	}()
	return out, nil
}

func registerLibVirt(cinp cinp.CInPClient) {
	cinp.RegisterType("/api/v1/LibVirt/LibVirtComplex", reflect.TypeOf((*LibvirtLibVirtComplex)(nil)).Elem())
	cinp.RegisterType("/api/v1/LibVirt/LibVirtFoundation", reflect.TypeOf((*LibvirtLibVirtFoundation)(nil)).Elem())
}
